
import { db } from '@/lib/firebase';
import { collection, addDoc, onSnapshot, query, orderBy, serverTimestamp, Timestamp, doc, deleteDoc, updateDoc, writeBatch, increment, getDocs } from 'firebase/firestore';

export interface Campaign {
  id: string;
  campaignName: string;
  smtpAccountId: string;
  recipientListId: string;
  emailVariants: { subject: string; body: string; }[];
  scheduleSend: boolean;
  scheduledAt: Date | null;
  speedLimit: number; // Max emails per hour
  status: 'Draft' | 'Scheduled' | 'Running' | 'Paused' | 'Completed' | 'Failed';
  createdAt: Date;
  sentCount: number;
  failedCount: number;
}

export interface CampaignFailure {
    id: string;
    recipient: string;
    error: string;
    timestamp: Date;
}

// Type for data sent to Firestore, omitting fields generated by the backend or managed separately
export type CampaignData = Omit<Campaign, 'id' | 'status' | 'createdAt' | 'sentCount' | 'failedCount'>;

export const addCampaign = async (userId: string, campaignData: Omit<CampaignData, 'scheduledAt'> & { scheduledAt: Date | null }) => {
    if (!userId) throw new Error('User not logged in');

    try {
        const docRef = await addDoc(collection(db, 'users', userId, 'campaigns'), {
            ...campaignData,
            status: campaignData.scheduleSend && campaignData.scheduledAt ? 'Scheduled' : 'Draft',
            createdAt: serverTimestamp(),
            // Ensure scheduledAt is a Timestamp or null
            scheduledAt: campaignData.scheduledAt ? Timestamp.fromDate(campaignData.scheduledAt) : null,
            sentCount: 0,
            failedCount: 0,
        });
        return docRef.id;
    } catch (error) {
        console.error("Error adding campaign: ", error);
        throw new Error("Failed to create campaign.");
    }
};

export const getCampaigns = (userId: string, callback: (campaigns: Campaign[]) => void) => {
    if (!userId) return () => {};

    const q = query(collection(db, 'users', userId, 'campaigns'), orderBy('createdAt', 'desc'));
    
    const unsubscribe = onSnapshot(q, (querySnapshot) => {
        const campaigns: Campaign[] = [];
        querySnapshot.forEach((doc) => {
            const data = doc.data();
            campaigns.push({
                id: doc.id,
                ...data,
                createdAt: (data.createdAt as Timestamp)?.toDate() || new Date(),
                scheduledAt: (data.scheduledAt as Timestamp)?.toDate() || null,
            } as Campaign);
        });
        callback(campaigns);
    }, (error) => {
        console.error("Error fetching campaigns: ", error);
    });

    return unsubscribe;
};

export const updateCampaign = async (userId: string, campaignId: string, data: { [key: string]: any }) => {
    if (!userId) throw new Error('User not logged in');
    try {
        const campaignRef = doc(db, 'users', userId, 'campaigns', campaignId);
        await updateDoc(campaignRef, data);
    } catch (error) {
        console.error("Error updating campaign: ", error);
        throw new Error("Failed to update campaign.");
    }
};

export const logCampaignFailure = async (userId: string, campaignId: string, recipient: string, error: string) => {
    if (!userId) throw new Error('User not logged in');
    try {
        const batch = writeBatch(db);
        const campaignRef = doc(db, 'users', userId, 'campaigns', campaignId);
        const failureRef = doc(collection(db, 'users', userId, 'campaigns', campaignId, 'failures'));

        batch.update(campaignRef, { failedCount: increment(1) });
        batch.set(failureRef, {
            recipient,
            error,
            timestamp: serverTimestamp(),
        });

        await batch.commit();
    } catch (e) {
        console.error("Error logging campaign failure: ", e);
        // Fallback to just updating the count if batch fails for some reason
        await updateDoc(doc(db, 'users', userId, 'campaigns', campaignId), {
            failedCount: increment(1)
        });
    }
};

export const getCampaignFailures = async (userId: string, campaignId: string): Promise<CampaignFailure[]> => {
    if (!userId) throw new Error('User not logged in');
    try {
        const failuresCol = collection(db, 'users', userId, 'campaigns', campaignId, 'failures');
        const q = query(failuresCol, orderBy('timestamp', 'desc'));
        const snapshot = await getDocs(q);
        
        const failures: CampaignFailure[] = [];
        snapshot.forEach((doc) => {
            const data = doc.data();
            failures.push({
                id: doc.id,
                recipient: data.recipient,
                error: data.error,
                timestamp: (data.timestamp as Timestamp)?.toDate() || new Date(),
            });
        });

        return failures;
    } catch (error) {
        console.error("Error fetching campaign failures: ", error);
        throw new Error("Could not fetch campaign failures.");
    }
};

export const deleteCampaign = async (userId: string, campaignId: string) => {
    if (!userId) throw new Error('User not logged in');
    try {
        await deleteDoc(doc(db, 'users', userId, 'campaigns', campaignId));
    } catch (error) {
        console.error("Error deleting campaign: ", error);
        throw new Error("Failed to delete campaign.");
    }
}
