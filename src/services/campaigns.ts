
import { db } from '@/lib/firebase';
import { collection, addDoc, onSnapshot, query, orderBy, serverTimestamp, Timestamp, doc, deleteDoc, updateDoc } from 'firebase/firestore';

export interface Campaign {
  id: string;
  campaignName: string;
  emailSubject: string;
  smtpAccountId: string;
  recipientListId: string;
  emailBody: string;
  scheduleSend: boolean;
  scheduledAt: Date | null;
  speedLimit: number; // Max emails per hour
  status: 'Draft' | 'Scheduled' | 'Running' | 'Paused' | 'Completed' | 'Failed';
  createdAt: Date;
  sentCount: number;
  failedCount: number;
}

// Type for data sent to Firestore, omitting fields generated by the backend or managed separately
export type CampaignData = Omit<Campaign, 'id' | 'status' | 'createdAt' | 'sentCount' | 'failedCount' | 'delay'>;

export const addCampaign = async (userId: string, campaignData: Omit<CampaignData, 'scheduledAt'> & { scheduledAt: Date | null }) => {
    if (!userId) throw new Error('User not logged in');

    try {
        const docRef = await addDoc(collection(db, 'users', userId, 'campaigns'), {
            ...campaignData,
            status: campaignData.scheduleSend && campaignData.scheduledAt ? 'Scheduled' : 'Draft',
            createdAt: serverTimestamp(),
            // Ensure scheduledAt is a Timestamp or null
            scheduledAt: campaignData.scheduledAt ? Timestamp.fromDate(campaignData.scheduledAt) : null,
            sentCount: 0,
            failedCount: 0,
        });
        return docRef.id;
    } catch (error) {
        console.error("Error adding campaign: ", error);
        throw new Error("Failed to create campaign.");
    }
};

export const getCampaigns = (userId: string, callback: (campaigns: Campaign[]) => void) => {
    if (!userId) return () => {};

    const q = query(collection(db, 'users', userId, 'campaigns'), orderBy('createdAt', 'desc'));
    
    const unsubscribe = onSnapshot(q, (querySnapshot) => {
        const campaigns: Campaign[] = [];
        querySnapshot.forEach((doc) => {
            const data = doc.data();
            campaigns.push({
                id: doc.id,
                ...data,
                createdAt: (data.createdAt as Timestamp)?.toDate(),
                scheduledAt: (data.scheduledAt as Timestamp)?.toDate() || null,
            } as Campaign);
        });
        callback(campaigns);
    }, (error) => {
        console.error("Error fetching campaigns: ", error);
    });

    return unsubscribe;
};

export const updateCampaign = async (userId: string, campaignId: string, data: { [key: string]: any }) => {
    if (!userId) throw new Error('User not logged in');
    try {
        const campaignRef = doc(db, 'users', userId, 'campaigns', campaignId);
        await updateDoc(campaignRef, data);
    } catch (error) {
        console.error("Error updating campaign: ", error);
        throw new Error("Failed to update campaign.");
    }
};

export const deleteCampaign = async (userId: string, campaignId: string) => {
    if (!userId) throw new Error('User not logged in');
    try {
        await deleteDoc(doc(db, 'users', userId, 'campaigns', campaignId));
    } catch (error) {
        console.error("Error deleting campaign: ", error);
        throw new Error("Failed to delete campaign.");
    }
}
